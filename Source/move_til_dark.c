#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorB,           motorR,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorL,      tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#define TYRE_RAD 2.8


float calibrateSquareLen(int lightThresh, int spd);
float degToCm(float deg, float rad);
float moveTilDark(int lightThresh, int spdLft, int spdRgt);
float moveTilDoubleLine(int lightThresh, int spacingThresh, int spdLft, int spdRgt);
float moveTilLight(int lightThresh, int spdLft, int spdRgt);
float moveTilLightChange(int lightThresh, int spdLft, int spdRgt);
float revToCm(float rev, float rad);


task main() {
	moveTilDoubleLine(45, 4.0, 35, 35);

	/*float sqLen;
	float travelled;

	sqLen = calibrateSquareLen(45, 35);
	nxtDisplayCenteredTextLine(0, "sqLen:");
	nxtDisplayCenteredBigTextLine(1, "%.2f", sqLen);

	travelled = moveTilDark(45, 35, 35);
	nxtDisplayCenteredTextLine(4, "travelled:");
	nxtDisplayCenteredBigTextLine(5, "%.2f", travelled);
	wait1Msec(5000);*/
}


/*
	Measure the length of one square on the grid.
	This includes the border.
	Measurements are in cm.
*/
float calibrateSquareLen(int lightThresh, int spd) {
	float sqLen;

	eraseDisplay();
	nxtDisplayTextLine(0, "Put me in front");
	nxtDisplayTextLine(1, "of 2 white squares.");
	while (SensorValue(touchSensor) == 0) {
	}
	eraseDisplay();

	sqLen = 0;

	// move up to the inner edge of the border
	moveTilLight(lightThresh, spd, spd);

	// measure the length of the white square
	sqLen += moveTilDark(lightThresh, spd, spd);

	// measure the width of the border
	sqLen += moveTilLight(lightThresh, spd, spd);

	return sqLen;
}


float moveTilDark(int lightThresh, int spdLft, int spdRgt) {
	enum lightBool {DARK = 0, LIGHT = 1};

	// current and previous light sensor readings
	lightBool currLight, prevLight;

	float encoderMean;
	float travelled;

	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;

	// convert light sensor reading to a boolean value
	currLight = (lightBool) (SensorValue(lightSensor) / lightThresh);

	// do until a new dark region is encountered
	do {
		// update sensor readings
		prevLight = currLight;
		currLight = (lightBool) (SensorValue(lightSensor) / lightThresh);

		motor[motorL] = spdLft;
		motor[motorR] = spdRgt;
	} while (currLight == LIGHT || prevLight == DARK);

	motor[motorL] = 0;
	motor[motorR] = 0;

	// measure distance travelled during function call
	encoderMean = (nMotorEncoder[motorL] + nMotorEncoder[motorL]) / 2;
	travelled = degToCm(encoderMean, TYRE_RAD);

	return travelled;
}


float moveTilLight(int lightThresh, int spdLft, int spdRgt) {
	enum lightBool {DARK = 0, LIGHT = 1};

	// current and previous light sensor readings
	lightBool currLight, prevLight;

	float encoderMean;
	float travelled;

	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;

	// convert light sensor reading to a boolean value
	currLight = (lightBool) (SensorValue(lightSensor) / lightThresh);

	// do until a new light region is encountered
	do {
		// update sensor readings
		prevLight = currLight;
		currLight = (lightBool) (SensorValue(lightSensor) / lightThresh);

		motor[motorL] = spdLft;
		motor[motorR] = spdRgt;
	} while (currLight == DARK || prevLight == LIGHT);

	motor[motorL] = 0;
	motor[motorR] = 0;

	// measure distance travelled during function call
	encoderMean = (nMotorEncoder[motorL] + nMotorEncoder[motorL]) / 2;
	travelled = degToCm(encoderMean, TYRE_RAD);

	return travelled;
}


float moveTilLightChange(int lightThresh, int spdLft, int spdRgt) {
	enum lightBool {DARK = 0, LIGHT = 1} ;

	// current and previous light sensor readings
	lightBool currLight, prevLight;

	float encoderMean;
	float travelled;

	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;

	// convert light sensor reading to a boolean value
	currLight = (lightBool) (SensorValue(lightSensor) / lightThresh);

	// do until current and previous readings are different
	do {
		// update sensor readings
		prevLight = currLight;
		currLight = (lightBool) (SensorValue(lightSensor) / lightThresh);

		motor[motorL] = spdLft;
		motor[motorR] = spdRgt;
	} while (currLight == prevLight);

	motor[motorL] = 0;
	motor[motorR] = 0;

	// measure distance travelled during function call
	encoderMean = (nMotorEncoder[motorL] + nMotorEncoder[motorL]) / 2;
	travelled = degToCm(encoderMean, TYRE_RAD);

	return travelled;
}


/*
	Move until it passes two dark lines whose spacing is less than a given threshold.
	(This threshold includes the width of the first line because I'm lazy.)
	Return the total distance travelled.
*/
float moveTilDoubleLine(int lightThresh, int spacingThresh, int spdLft, int spdRgt) {
	float recentDist, totalDist;

	totalDist = 0;

	do {
		recentDist = moveTilDark(lightThresh, spdLft, spdRgt);
		totalDist += recentDist;
	} while (recentDist > spacingThresh);

	return totalDist;
}


float degToCm(float deg, float rad) {
	return revToCm(deg, rad) / 360;
}


float revToCm(float rev, float rad) {
	return rev * (2 * PI * rad);
}
