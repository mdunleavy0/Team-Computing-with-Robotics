#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorB,          motorR,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorL,      tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


int calibrateRotation(int lightThresh, int spd);
void pivot(int angle, int rotationDist, int spd);


task main() {
	int rotationDist;

	rotationDist = calibrateRotation(45, 30);
	nxtDisplayCenteredBigTextLine(0, "%d", rotationDist);

	eraseDisplay();
	nxtDisplayCenteredTextLine(0, "Touch now");
	while (SensorValue(touchSensor) == 0) {
	}
	eraseDisplay();

	pivot(90, rotationDist, 30);
	wait1Msec(1500);
	pivot(-180, rotationDist, 30);
}


/*
	Measure how many degrees the wheels must turn to perform a 180 deg
	point turn. Multiplies that result by 2 for a full 360 deg
	rotation and returns it.
*/
int calibrateRotation(int lightThresh, int spd) {
	enum lightBool {DARK = 0, LIGHT = 1};

	// current and previous light sensor readings
	lightBool currLight, prevLight;

	int encoderMean;

	motor[motorL] = 0;
	motor[motorR] = 0;

	eraseDisplay();
	nxtDisplayTextLine(0, "Put me on the");
	nxtDisplayTextLine(1, "right edge of a");
	nxtDisplayTextLine(2, "straight line.");
	while (SensorValue(touchSensor) == 0) {
	}
	eraseDisplay();

	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;

	// convert light sensor reading to a boolean value
	currLight = (lightBool) (SensorValue(lightSensor) / lightThresh);

	// do until a new dark region is encountered
	do {
		// update sensor readings
		prevLight = currLight;
		currLight = (lightBool) (SensorValue(lightSensor) / lightThresh);

		motor[motorL] = spd;
		motor[motorR] = -spd;
	} while (currLight == LIGHT || prevLight == DARK);

	motor[motorL] = 0;
	motor[motorR] = 0;

	// return average of the encoder readings multiplied by 2
	encoderMean = (nMotorEncoder[motorL] + nMotorEncoder[motorL]) / 2;
	return encoderMean * 2;
}


void pivot(int angle, int rotationDist, int spd) {
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;

	nMotorEncoderTarget[motorL] = abs(angle) * (rotationDist / 360);
	nMotorEncoderTarget[motorR] = abs(angle) * (rotationDist / 360);

	if (angle > 0) {
		motor[motorL] = -spd;
		motor[motorR] = spd;
	}
	else {
		motor[motorL] = spd;
		motor[motorR] = -spd;
	}

	while (
		nMotorRunState[motorB] != runStateIdle ||
		nMotorRunState[motorC] != runStateIdle
	) {
	}

	motor[motorL] = 0;
	motor[motorR] = 0;
}
